package com.niuzj.pattern;

/**
 * 命令模式
 * Receiver: 接收者， 它知道如何处理具体的业务逻辑。
 * Command: 抽象命令， 它定义了 一个命令对象 应具备的 一系列命令操作， 比如
 * execute ()、 undo()、 redo()等。 当命令操作被调用的时候就会触发接收者去
 * 做具体命令对应的业务逻辑。
 * ConcreteCommand: 具体的命令实现， 在这里它绑定了命令操作与接收者之间的
 * 关系， execute()命令的实现委托给了Receiver的 action()函数。
 * Invoker: 调用者， 它持有一个命令对象， 并且可以在需要的时候通过命令对象完
 * 成具体的业务逻辑。
 *
 * 在下面这些情况下应考虑使用命令模式。
 * • 使用命令模式作为 “ 回调(CallBack) "在面向对象系统中的替代。"CallBack"讲的
 * 便是先将 一个函数登记上， 然后在以后调用此函数。
 * • 需要在不同的时间指定请求、 将请求排队。 一个命令对象和原先的请求发出者可以
 * 有不同的生命期。 换言之， 原先的请求发出者可能已经不在了， 而命令对象本身仍
 * 然是活动的。这时命令的接收者可以是在本地， 也可以在网络的另外一个地址。命
 * 令对象可以在序列化之后传送到另外一台机器上去。
 * • 系统需要支持命令的撤销。命令对象可以把状态存储起来， 等到 客户端需要撤销命
 * 令所产生的效果时， 可以调用undo()方法， 把命令所产生的效果撤销掉。命令对
 * 象还可以提供redo()方法， 以供客户端在需要时再重新实施命令效果。
 * • 如果要将系统中所有的数据更新到日志里，以便在系统 崩溃时，可以根据日志读回
 * 所有的数据更新命令， 重新 调用 execute()方法 一条一条执行 这些命令， 从而恢
 * 复系统在崩溃前所做的数据更新。
 */
public class TestApplication {

    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        new Invoker(new ConcreteCommand(receiver)).action();
    }

}
